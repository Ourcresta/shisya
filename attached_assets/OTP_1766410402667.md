# OTP (One-Time Password) System Documentation

## Overview

Ourcresta POS uses a secure OTP (One-Time Password) system for user authentication and verification. OTPs are sent via email using the **Resend** email service and stored securely with SHA-256 hashing.

## Architecture

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Client    │────▶│  Send OTP   │────▶│   Resend    │────▶│   User's    │
│   (React)   │     │   API       │     │   Email     │     │   Inbox     │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
       │                   │
       │                   ▼
       │            ┌─────────────┐
       │            │  Database   │
       │            │  (OTP Hash) │
       │            └─────────────┘
       │                   ▲
       ▼                   │
┌─────────────┐     ┌─────────────┐
│   Enter     │────▶│  Verify OTP │
│   OTP       │     │   API       │
└─────────────┘     └─────────────┘
```

## Key Features

- **6-digit numeric OTP** for easy entry
- **2-minute expiration** for security
- **3 attempt limit** to prevent brute force attacks
- **SHA-256 hashing** - OTP is never stored in plain text
- **Purpose-based validation** (signup, login, forgot_password, verify_email)
- **Professional HTML email templates**

---

## File Structure

```
lib/
├── auth.ts          # OTP generation, hashing, validation utilities
├── email.ts         # Resend integration and email templates
├── otp.ts           # Database OTP record management

api/auth/
├── send-otp.ts      # POST /api/auth/send-otp
├── verify-otp.ts    # POST /api/auth/verify-otp

shared/
├── schema.ts        # otpLogs table schema
```

---

## Database Schema

The `otpLogs` table stores OTP records:

```typescript
// shared/schema.ts
export const otpLogs = pgTable("otp_logs", {
  id: text("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  userId: text("user_id").references(() => users.id),
  contactType: text("contact_type").notNull(), // "email" or "mobile"
  destination: text("destination").notNull(),  // email address or phone
  otpHash: text("otp_hash").notNull(),         // SHA-256 hash (never plain text)
  purpose: text("purpose").notNull(),          // signup, login, etc.
  attemptCount: integer("attempt_count").default(0),
  expiresAt: timestamp("expires_at").notNull(),
  consumedAt: timestamp("consumed_at"),        // null until used
  createdAt: timestamp("created_at").defaultNow(),
});
```

---

## Core Utilities (lib/auth.ts)

### OTP Generation

```typescript
// Generate a 6-digit random OTP
export function generateOTP(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}
// Output: "384751"
```

### OTP Hashing (Security)

```typescript
import crypto from "crypto";

// Hash OTP using SHA-256 (never store plain OTP)
export function hashOTP(otp: string): string {
  return crypto.createHash("sha256").update(otp).digest("hex");
}
// Input: "384751"
// Output: "a3f2b8c1d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6..."
```

### OTP Verification

```typescript
export function verifyOTP(otp: string, hash: string): boolean {
  return hashOTP(otp) === hash;
}
// Compares the hash of user input with stored hash
```

### OTP Expiry

```typescript
const OTP_EXPIRES_IN = 2 * 60 * 1000; // 2 minutes in milliseconds

export function getOTPExpiry(): Date {
  return new Date(Date.now() + OTP_EXPIRES_IN);
}

export function isOTPExpired(expiresAt: Date): boolean {
  return new Date() > expiresAt;
}
```

---

## Email Integration (lib/email.ts)

### Resend Setup

```typescript
import { Resend } from "resend";

let resendClient: Resend | null = null;

function getResendClient(): Resend {
  if (!resendClient) {
    const apiKey = process.env.RESEND_API_KEY;
    if (!apiKey) {
      throw new Error("RESEND_API_KEY environment variable is required");
    }
    resendClient = new Resend(apiKey);
  }
  return resendClient;
}
```

### Send Generic Email

```typescript
export type SendEmailOptions = {
  to: string | string[];
  subject: string;
  html: string;
  from?: string;
};

export async function sendEmail({ to, subject, html, from }: SendEmailOptions) {
  try {
    const client = getResendClient();
    const sender = from ?? process.env.RESEND_FROM_EMAIL || "noreply@ourcresta.com";
    
    const result = await client.emails.send({
      from: sender,
      to: Array.isArray(to) ? to : [to],
      subject,
      html,
    });
    
    return { success: true, result };
  } catch (error) {
    console.error("Resend email error:", error);
    return { success: false, error: error instanceof Error ? error.message : "Unknown error" };
  }
}
```

### Send OTP Email with Template

```typescript
export async function sendOTPEmail(email: string, otp: string, purpose: string) {
  const purposeText = {
    signup: "complete your registration",
    login: "log in to your account",
    forgot_password: "reset your password",
    verify_email: "verify your email address",
  }[purpose] || "verify your identity";

  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; background-color: #f5f5f5;">
      <div style="background-color: #ffffff; border-radius: 12px; padding: 40px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
        <div style="text-align: center; margin-bottom: 32px;">
          <h1 style="color: #1a1a1a; margin: 0; font-size: 24px; font-weight: 700;">Ourcresta POS</h1>
          <p style="color: #666; margin: 8px 0 0 0; font-size: 14px;">Verification Code</p>
        </div>
        
        <p style="color: #333; font-size: 16px; line-height: 1.6; margin-bottom: 24px;">
          Your one-time password (OTP) to ${purposeText}:
        </p>
        
        <div style="text-align: center; margin: 32px 0;">
          <div style="display: inline-block; background: linear-gradient(135deg, #2563eb 0%, #4f46e5 100%); color: white; font-size: 32px; font-weight: 700; letter-spacing: 8px; padding: 20px 40px; border-radius: 12px; font-family: 'Courier New', monospace;">
            ${otp}
          </div>
        </div>
        
        <p style="color: #666; font-size: 14px; text-align: center; margin-bottom: 24px;">
          This code expires in <strong>2 minutes</strong>.
        </p>
        
        <div style="background-color: #fef3c7; border-left: 4px solid #f59e0b; padding: 12px 16px; border-radius: 0 8px 8px 0; margin-top: 24px;">
          <p style="color: #92400e; font-size: 13px; margin: 0;">
            <strong>Security Notice:</strong> Never share this OTP with anyone. Ourcresta staff will never ask for your OTP.
          </p>
        </div>
        
        <div style="text-align: center; padding-top: 32px; border-top: 1px solid #eee; margin-top: 32px;">
          <p style="margin: 0; color: #999; font-size: 12px;">Ourcresta POS Lite</p>
          <p style="margin: 4px 0 0 0; color: #bbb; font-size: 11px;">Powered by Ourcresta Technologies</p>
        </div>
      </div>
    </body>
    </html>
  `;

  return sendEmail({
    to: email,
    subject: `${otp} is your Ourcresta POS verification code`,
    html,
  });
}
```

---

## OTP Database Operations (lib/otp.ts)

### Create OTP Record

```typescript
import { getDb } from "./db";
import { otpLogs } from "../shared/schema";
import { hashOTP, getOTPExpiry } from "./auth";

export async function createOTPRecord(
  userId: string | null,
  contactType: "email" | "mobile",
  destination: string,
  otp: string,
  purpose: string
): Promise<void> {
  const db = getDb();
  
  await db.insert(otpLogs).values({
    userId,
    contactType,
    destination,
    otpHash: hashOTP(otp),  // Store hash, not plain OTP
    purpose,
    expiresAt: getOTPExpiry(),
    attemptCount: 0,
  });
}
```

### Verify OTP Record

```typescript
import { eq, and, gt, isNull } from "drizzle-orm";
import { verifyOTP as verifyOTPHash, isOTPExpired } from "./auth";

export async function verifyOTPRecord(
  destination: string,
  otp: string,
  purpose: string
): Promise<{ valid: boolean; userId?: string; message?: string }> {
  const db = getDb();
  
  // Find unexpired, unconsumed OTP for this destination and purpose
  const records = await db
    .select()
    .from(otpLogs)
    .where(
      and(
        eq(otpLogs.destination, destination),
        eq(otpLogs.purpose, purpose),
        isNull(otpLogs.consumedAt),           // Not yet used
        gt(otpLogs.expiresAt, new Date())     // Not expired
      )
    )
    .orderBy(otpLogs.createdAt)
    .limit(1);
  
  if (records.length === 0) {
    return { valid: false, message: "No valid OTP found. Please request a new one." };
  }
  
  const record = records[0];
  
  // Check if expired
  if (isOTPExpired(record.expiresAt)) {
    return { valid: false, message: "OTP has expired. Please request a new one." };
  }
  
  // Check attempt limit (max 3)
  if ((record.attemptCount || 0) >= 3) {
    return { valid: false, message: "Too many failed attempts. Please request a new OTP." };
  }
  
  // Verify OTP hash
  if (!verifyOTPHash(otp, record.otpHash)) {
    // Increment attempt counter on failure
    await db
      .update(otpLogs)
      .set({ attemptCount: (record.attemptCount || 0) + 1 })
      .where(eq(otpLogs.id, record.id));
    
    return { valid: false, message: "Invalid OTP. Please try again." };
  }
  
  // Mark as consumed on success
  await db
    .update(otpLogs)
    .set({ consumedAt: new Date() })
    .where(eq(otpLogs.id, record.id));
  
  return { valid: true, userId: record.userId || undefined };
}
```

### Cleanup Expired OTPs

```typescript
export async function cleanExpiredOTPs(): Promise<void> {
  const db = getDb();
  
  await db
    .delete(otpLogs)
    .where(
      and(
        gt(new Date(), otpLogs.expiresAt)
      )
    );
}
```

---

## API Endpoints

### POST /api/auth/send-otp

Sends an OTP to the user's email address.

**Request Body:**
```json
{
  "email": "user@example.com",
  "purpose": "signup"  // signup | login | forgot_password | verify_email
}
```

**Response (Success):**
```json
{
  "success": true,
  "message": "OTP sent successfully"
}
```

**Response (Error):**
```json
{
  "message": "Email already registered"
}
```

**Implementation:**

```typescript
// api/auth/send-otp.ts
import { z } from "zod";
import { jsonResponse, errorResponse, validationError } from "../../lib/response";
import { generateOTP, validateEmail } from "../../lib/auth";
import { sendOTPEmail } from "../../lib/email";
import { createOTPRecord } from "../../lib/otp";
import * as storage from "../../lib/storage";

const sendOtpSchema = z.object({
  email: z.string().email("Invalid email address"),
  purpose: z.enum(["signup", "login", "forgot_password", "verify_email"]),
});

export default async function handler(req: Request): Promise<Response> {
  if (req.method !== "POST") {
    return errorResponse("Method not allowed", 405);
  }

  try {
    const body = await req.json();
    const validation = sendOtpSchema.safeParse(body);
    
    if (!validation.success) {
      return validationError(validation.error.errors);
    }

    const { email, purpose } = validation.data;

    // Validate email format
    if (!validateEmail(email)) {
      return errorResponse("Invalid email format");
    }

    // Check user existence based on purpose
    const user = await storage.getUserByEmail(email);

    if (purpose === "signup" && user) {
      return errorResponse("Email already registered", 409);
    }

    if (["login", "forgot_password", "verify_email"].includes(purpose) && !user) {
      return errorResponse("Email not found", 404);
    }

    // Generate OTP
    const otp = generateOTP();
    
    // Save to database (hashed)
    await createOTPRecord(user?.id || null, "email", email, otp, purpose);

    // Send via Resend
    const result = await sendOTPEmail(email, otp, purpose);

    if (!result.success) {
      return errorResponse("Failed to send OTP email", 500);
    }

    return jsonResponse({
      success: true,
      message: "OTP sent successfully",
    });

  } catch (error) {
    console.error("Send OTP error:", error);
    return errorResponse("Failed to send OTP", 500);
  }
}
```

---

### POST /api/auth/verify-otp

Verifies the OTP entered by the user.

**Request Body:**
```json
{
  "email": "user@example.com",
  "otp": "384751",
  "purpose": "signup"
}
```

**Response (Success - with auth cookies):**
```json
{
  "success": true,
  "message": "OTP verified successfully",
  "user": {
    "id": "uuid",
    "email": "user@example.com",
    "isEmailVerified": true
  }
}
```

**Implementation:**

```typescript
// api/auth/verify-otp.ts
import { z } from "zod";
import { jsonResponse, errorResponse, validationError } from "../../lib/response";
import { setAuthCookies } from "../../lib/cookies";
import { 
  generateAccessToken, generateRefreshToken, hashToken, 
  getRefreshTokenExpiry, sanitizeUser 
} from "../../lib/auth";
import { verifyOTPRecord } from "../../lib/otp";
import * as storage from "../../lib/storage";

const verifyOtpSchema = z.object({
  email: z.string().email("Invalid email address"),
  otp: z.string().length(6, "OTP must be 6 digits"),
  purpose: z.enum(["signup", "login", "forgot_password", "verify_email"]),
});

export default async function handler(req: Request): Promise<Response> {
  if (req.method !== "POST") {
    return errorResponse("Method not allowed", 405);
  }

  try {
    const body = await req.json();
    const validation = verifyOtpSchema.safeParse(body);
    
    if (!validation.success) {
      return validationError(validation.error.errors);
    }

    const { email, otp, purpose } = validation.data;

    // Verify OTP against database
    const verifyResult = await verifyOTPRecord(email, otp, purpose);

    if (!verifyResult.valid) {
      return errorResponse(verifyResult.message || "Invalid OTP", 400);
    }

    const user = await storage.getUserByEmail(email);
    
    if (!user) {
      return errorResponse("User not found", 404);
    }

    // Mark email as verified
    if (purpose === "signup" || purpose === "verify_email") {
      await storage.updateUser(user.id, {
        isEmailVerified: true,
        emailVerifiedAt: new Date(),
      });
    }

    // Generate auth tokens for login purposes
    if (purpose === "signup" || purpose === "login" || purpose === "verify_email") {
      await storage.updateUser(user.id, {
        lastLoginAt: new Date(),
        loginAttempts: 0,
        lockoutUntil: null,
      });

      const accessToken = generateAccessToken({
        userId: user.id,
        email: user.email!,
        mobile: user.mobile || undefined,
      });

      const refreshToken = generateRefreshToken();
      const refreshTokenHash = hashToken(refreshToken);
      
      await storage.createRefreshToken(user.id, refreshTokenHash, getRefreshTokenExpiry());

      const cookies = setAuthCookies(accessToken, refreshToken);
      const updatedUser = await storage.getUserById(user.id);

      return new Response(JSON.stringify({
        success: true,
        message: "OTP verified successfully",
        user: sanitizeUser(updatedUser!),
      }), {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Set-Cookie": cookies.join(", "),
        },
      });
    }

    // For forgot_password, just confirm OTP validity
    return jsonResponse({
      success: true,
      message: "OTP verified. You can now reset your password.",
      userId: user.id,
    });

  } catch (error) {
    console.error("Verify OTP error:", error);
    return errorResponse("Failed to verify OTP", 500);
  }
}
```

---

## Security Features

### 1. OTP is Never Stored in Plain Text
```typescript
// Before storing
const otp = "384751";
const hash = hashOTP(otp);  // SHA-256 hash stored in database
```

### 2. Rate Limiting (3 Attempts Max)
```typescript
if ((record.attemptCount || 0) >= 3) {
  return { valid: false, message: "Too many failed attempts." };
}
```

### 3. Short Expiration (2 Minutes)
```typescript
const OTP_EXPIRES_IN = 2 * 60 * 1000; // 2 minutes
```

### 4. One-Time Use
```typescript
// After successful verification
await db
  .update(otpLogs)
  .set({ consumedAt: new Date() })
  .where(eq(otpLogs.id, record.id));
```

### 5. Purpose Validation
OTPs are tied to a specific purpose and cannot be reused for different actions.

---

## Environment Variables

| Variable | Description | Required |
|----------|-------------|----------|
| `RESEND_API_KEY` | Resend API key for email delivery | Yes |
| `RESEND_FROM_EMAIL` | Sender email (default: noreply@ourcresta.com) | No |
| `DATABASE_URL` | PostgreSQL connection string | Yes |

---

## Flow Diagrams

### Signup with OTP

```
1. User enters email/password → POST /api/auth/signup
2. Backend creates user (unverified) → Generates OTP → Stores hash
3. Resend sends email with OTP
4. User enters OTP → POST /api/auth/verify-otp
5. Backend verifies hash → Marks email verified → Returns auth tokens
```

### Login with OTP

```
1. User enters email → POST /api/auth/send-otp (purpose: login)
2. Backend generates OTP → Stores hash → Resend sends email
3. User enters OTP → POST /api/auth/verify-otp (purpose: login)
4. Backend verifies hash → Returns auth tokens
```

### Forgot Password with OTP

```
1. User enters email → POST /api/auth/send-otp (purpose: forgot_password)
2. Backend generates OTP → Stores hash → Resend sends email
3. User enters OTP → POST /api/auth/verify-otp (purpose: forgot_password)
4. Backend verifies hash → Returns userId for password reset
5. User sets new password → POST /api/auth/reset-password
```

---

## Testing

### Test Email Endpoint

```bash
curl -X POST https://your-app.vercel.app/api/email/test \
  -H "Content-Type: application/json" \
  -d '{"to": "test@example.com"}'
```

### Send OTP

```bash
curl -X POST https://your-app.vercel.app/api/auth/send-otp \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "purpose": "signup"}'
```

### Verify OTP

```bash
curl -X POST https://your-app.vercel.app/api/auth/verify-otp \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "otp": "384751", "purpose": "signup"}'
```

---

## Troubleshooting

### OTP Email Not Received

1. Check `RESEND_API_KEY` is set correctly
2. Verify sender domain is verified in Resend dashboard
3. Check spam folder
4. Review Resend dashboard for delivery logs

### "OTP has expired" Error

OTP is valid for only 2 minutes. Request a new one.

### "Too many failed attempts" Error

After 3 wrong attempts, the OTP is invalidated. Request a new one.

### "No valid OTP found" Error

The OTP may have already been used (consumed) or expired. Request a new one.

---

## Best Practices

1. **Never log plain OTPs** - Always log hashed values or reference IDs only
2. **Clean up expired OTPs** - Run `cleanExpiredOTPs()` periodically
3. **Use HTTPS only** - OTPs should only travel over encrypted connections
4. **Limit OTP requests** - Implement rate limiting on `/api/auth/send-otp`
5. **Monitor unusual activity** - Track multiple failed attempts per user/IP
